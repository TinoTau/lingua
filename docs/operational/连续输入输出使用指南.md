# 连续输入输出使用指南

## 一、功能概述

连续输入输出功能允许系统在截取上一段音频进行翻译的同时，继续接收下一段音频输入。这实现了真正的**全双工音频处理**。

## 二、启用方式

### 2.1 在 CoreEngineBuilder 中启用

```rust
use core_engine::{CoreEngineBuilder, TimeBasedVad};

let engine = CoreEngineBuilder::new()
    // ... 其他配置 ...
    .vad(Arc::new(TimeBasedVad::new(3000)))  // 3秒间隔的 VAD
    .with_continuous_mode(
        true,              // 启用连续模式
        5000,              // 最大缓冲时长：5秒（符合第二阶段目标：3-5秒）
        200,               // 最小片段时长：200ms
    )
    .build()?;
```

### 2.2 配置参数说明

- **`enabled`**: 是否启用连续模式
- **`max_buffer_duration_ms`**: 最大缓冲时长（毫秒）
  - 如果用户一直说话不停顿，超过此时长会强制截断
  - **默认值**：5000ms（5秒，符合第二阶段目标：3-5秒）
  - 建议值：3000-5000ms（3-5秒）
- **`min_segment_duration_ms`**: 最小片段时长（毫秒）
  - 如果检测到的片段太短，会继续累积到下一个边界
  - 建议值：200-500ms

## 三、VAD 选择

### 3.1 固定时间间隔 VAD（当前实现）

**优点**：
- 实现简单，无需外部依赖
- 延迟低，无需模型推理
- 适合快速测试和原型开发

**缺点**：
- 无法识别自然停顿
- 可能在句子中间截断

**使用方式**：
```rust
use core_engine::vad::TimeBasedVad;

let vad = Arc::new(TimeBasedVad::new(3000));  // 3秒间隔
```

### 3.2 Silero VAD（推荐，待实现）

**优点**：
- 准确识别自然停顿
- 延迟低（~10-20ms）
- 支持多种语言

**缺点**：
- 需要下载模型文件（~1.5MB）
- 需要 ONNX Runtime 支持

**使用方式**（待实现）：
```rust
use core_engine::vad::SileroVad;

let vad = Arc::new(SileroVad::new("path/to/silero_vad.onnx")?);
```

## 四、工作原理

### 4.1 处理流程

```
音频输入 → 缓冲队列 → VAD 检测 → [边界检测] → ASR 推理 → NMT 翻译 → TTS 合成 → 音频输出
                ↓
            继续接收新音频
```

### 4.2 双缓冲机制

1. **当前缓冲区**：累积音频帧，等待 VAD 检测到边界
2. **备用缓冲区**：接收新的音频输入
3. **边界检测**：当 VAD 检测到边界时：
   - 提交当前缓冲区的内容给 ASR
   - 切换到备用缓冲区继续接收新音频
   - 异步处理当前片段（不阻塞音频接收）

### 4.3 异步处理

当检测到边界时，系统会：
1. 立即切换到新缓冲区（继续接收音频）
2. 在后台任务中处理当前片段（ASR → NMT → TTS）
3. 处理完成后，将 TTS 音频添加到输出队列

## 五、性能优化建议

### 5.1 缓冲区大小

- **过小**：可能导致频繁截断，影响用户体验
- **过大**：可能导致延迟增加，内存占用增加
- **建议**：根据实际使用场景调整（例如 5-10 秒）

### 5.2 VAD 参数调优

**固定时间间隔 VAD**：
- 短间隔（1-2秒）：响应快，但可能截断句子
- 长间隔（5-10秒）：减少截断，但延迟增加
- **建议**：3-5秒

**Silero VAD**（待实现）：
- `silence_threshold`: 静音阈值（0.0-1.0），建议 0.5
- `min_silence_duration_ms`: 最小静音时长，建议 500ms

### 5.3 并发处理

系统支持同时处理多个音频片段：
- ASR、NMT、TTS 可以并行处理
- 使用 Rust 的 `tokio` 异步运行时
- 通过 `Arc` 和 `RwLock` 实现线程安全

## 六、故障排查

### 6.1 缓冲区溢出

**症状**：日志中出现 "Buffer overflow" 错误

**原因**：用户说话时间过长，超过 `max_buffer_duration_ms`

**解决方案**：
1. 增加 `max_buffer_duration_ms`（例如 15-20 秒）
2. 使用更好的 VAD（例如 Silero VAD）来更早检测边界
3. 检查 VAD 是否正常工作

### 6.2 片段过短

**症状**：日志中出现 "Segment too short" 警告

**原因**：检测到的片段时长小于 `min_segment_duration_ms`

**解决方案**：
1. 降低 `min_segment_duration_ms`（例如 100ms）
2. 调整 VAD 参数，减少误检测

### 6.3 音频同步问题

**症状**：TTS 音频播放顺序错乱

**原因**：多个片段并发处理，输出顺序不确定

**解决方案**：
- 系统已实现序列号机制，确保输出顺序
- 如果仍有问题，检查事件总线的事件顺序

## 七、示例代码

### 7.1 完整示例

```rust
use core_engine::{
    CoreEngineBuilder,
    vad::TimeBasedVad,
    // ... 其他导入 ...
};

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // 创建 VAD（固定时间间隔，3秒）
    let vad = Arc::new(TimeBasedVad::new(3000));
    
    // 创建 CoreEngine
    let engine = CoreEngineBuilder::new()
        .vad(vad)
        .asr(/* ASR 配置 */)
        .nmt(/* NMT 配置 */)
        .tts(/* TTS 配置 */)
        // ... 其他配置 ...
        .with_continuous_mode(
            true,    // 启用连续模式
            10000,   // 最大缓冲时长：10秒
            200,     // 最小片段时长：200ms
        )
        .build()?;
    
    // 初始化
    engine.initialize().await?;
    
    // 处理音频帧（连续输入）
    loop {
        let frame = receive_audio_frame().await;
        let _result = engine.process_audio_frame(frame, None).await?;
        // 继续接收下一个帧，不等待处理完成
    }
    
    Ok(())
}
```

## 八、后续改进

1. **集成 Silero VAD**：实现更准确的自然停顿识别
2. **自适应缓冲**：根据用户说话速度动态调整缓冲区大小
3. **音频同步优化**：改进多片段并发处理的同步机制
4. **性能监控**：添加详细的性能指标和监控

## 九、参考资料

- [连续输入输出与自然停顿识别方案](./连续输入输出与自然停顿识别方案.md)
- [Silero VAD GitHub](https://github.com/snakers4/silero-vad)
- [ONNX Runtime Rust](https://docs.rs/ort/)

