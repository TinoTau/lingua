# 客户端 UI 和 WebSocket 流式功能说明

## 一、客户端 UI

### 1.1 什么是客户端 UI？

**客户端 UI** 是指用户直接使用的界面程序，它负责：
- 与用户交互（显示界面、接收操作）
- 采集麦克风音频
- 调用 CoreEngine 服务
- 播放翻译后的语音
- 显示转录和翻译文本

### 1.2 客户端 UI 的类型

根据设计文档，Lingua 支持多种客户端形态：

#### 1.2.1 Chrome Extension（Chrome 浏览器插件）

**位置：** `clients/chrome_extension/`

**功能：**
- 浏览器内运行
- 使用 `MediaRecorder API` 采集音频
- 使用 `Web Audio API` 播放音频
- 通过 HTTP/WebSocket 与 CoreEngine 通信

**当前状态：**
- ✅ 框架已搭建（`engineBridge.ts`, `audioCapture.ts`）
- ⚠️ UI 组件部分实现（`ui/` 目录）
- ❌ 完整的用户界面未完成

**示例界面元素：**
```
┌─────────────────────────────┐
│   Lingua 实时翻译            │
├─────────────────────────────┤
│  [开始] [停止] [设置]        │
│                             │
│  源语言: [English ▼]        │
│  目标语言: [中文 ▼]         │
│                             │
│  转录文本:                  │
│  "Hello world"              │
│                             │
│  翻译文本:                  │
│  "你好世界"                 │
│                             │
│  状态: ● 正在翻译...        │
└─────────────────────────────┘
```

#### 1.2.2 Electron 桌面应用

**位置：** `clients/electron/`

**功能：**
- 独立的桌面应用程序
- 使用系统音频 API 采集和播放
- 更强大的系统集成能力

**当前状态：**
- ⚠️ 框架已搭建（`main/`, `renderer/` 目录）
- ❌ UI 未实现

#### 1.2.3 移动端应用

**位置：** `clients/mobile/`

**功能：**
- Android/iOS 原生应用
- 使用移动端音频 API

**当前状态：**
- ❌ 未开始开发

#### 1.2.4 Web PWA（渐进式 Web 应用）

**位置：** `clients/web_pwa/`

**功能：**
- 基于 Web 的应用
- 可在浏览器或作为独立应用运行

**当前状态：**
- ❌ 未开始开发

### 1.3 客户端 UI 需要实现的功能

**核心功能：**
1. **音频采集**
   - 麦克风权限请求
   - 实时音频流采集
   - 音频格式转换

2. **与 CoreEngine 通信**
   - HTTP 客户端（调用 `/s2s` 接口）
   - WebSocket 客户端（连接 `/stream` 接口）
   - 错误处理和重试

3. **音频播放**
   - 接收翻译后的音频
   - 实时播放
   - 音量控制

4. **用户界面**
   - 启动/停止按钮
   - 语言选择
   - 转录文本显示
   - 翻译文本显示
   - 状态指示器

5. **配置管理**
   - 服务地址配置
   - 语言对配置
   - 音频设备选择

---

## 二、WebSocket 流式翻译

### 2.1 什么是 WebSocket 流式翻译？

**WebSocket 流式翻译** 是一种实时、双向通信的翻译方式，与 HTTP 的"整句翻译"不同：

| 特性 | HTTP 整句翻译 | WebSocket 流式翻译 |
|------|--------------|-------------------|
| **通信方式** | 请求-响应（一次性） | 双向连接（持续） |
| **音频输入** | 一次性发送完整音频 | 持续发送音频片段 |
| **结果输出** | 等待完整结果 | 实时推送部分结果 |
| **延迟** | 较高（等待完整处理） | 较低（实时处理） |
| **适用场景** | 离线音频文件翻译 | 实时对话翻译 |

### 2.2 WebSocket 流式翻译的工作流程

```
客户端                          CoreEngine 服务
  │                                 │
  │─── WebSocket 连接 ──────────────>│
  │                                 │
  │─── 发送: {action: "start"} ────>│  启动流式翻译会话
  │                                 │
  │─── 发送: {action: "audio",      │
  │           data: "<chunk1>"} ───>│  处理音频片段 1
  │                                 │─── ASR 部分结果
  │<── 接收: {type: "partial",      │
  │           text: "Hello"} ───────│
  │                                 │
  │─── 发送: {action: "audio",      │
  │           data: "<chunk2>"} ───>│  处理音频片段 2
  │                                 │─── ASR 完整结果
  │<── 接收: {type: "final",        │
  │           text: "Hello world"} ─│
  │                                 │─── NMT 翻译
  │<── 接收: {type: "translation",  │
  │           text: "你好世界"} ────│
  │                                 │─── TTS 合成
  │<── 接收: {type: "audio",        │
  │           data: "<wav_data>"} ──│
  │                                 │
  │─── 发送: {action: "stop"} ─────>│  停止流式翻译
  │                                 │
  │<── WebSocket 关闭 ──────────────│
```

### 2.3 WebSocket 消息协议（设计）

根据设计文档，WebSocket 接口包括：

#### 2.3.1 客户端 → 服务器

**启动流式翻译：**
```json
{
  "action": "start",
  "src_lang": "en",
  "tgt_lang": "zh"
}
```

**发送音频数据：**
```json
{
  "action": "audio",
  "data": "<base64_encoded_audio_chunk>",
  "timestamp": 1234567890
}
```

**停止流式翻译：**
```json
{
  "action": "stop"
}
```

#### 2.3.2 服务器 → 客户端

**ASR 部分结果：**
```json
{
  "type": "partial",
  "text": "Hello",
  "confidence": 0.95,
  "timestamp": 1234567890
}
```

**ASR 最终结果：**
```json
{
  "type": "final",
  "text": "Hello world",
  "confidence": 0.98,
  "timestamp": 1234567890
}
```

**翻译结果：**
```json
{
  "type": "translation",
  "text": "你好世界",
  "timestamp": 1234567891
}
```

**TTS 音频：**
```json
{
  "type": "audio",
  "data": "<base64_encoded_wav_audio>",
  "timestamp": 1234567892,
  "is_last": false
}
```

**错误消息：**
```json
{
  "type": "error",
  "message": "Error description",
  "code": "ERROR_CODE"
}
```

### 2.4 WebSocket 流式翻译的优势

1. **低延迟**
   - 不需要等待完整音频
   - 实时处理音频片段
   - 部分结果立即推送

2. **更好的用户体验**
   - 实时看到转录文本
   - 实时看到翻译结果
   - 增量播放翻译语音

3. **资源效率**
   - 不需要缓存完整音频
   - 可以提前开始处理
   - 支持长时间对话

### 2.5 当前实现状态

**服务器端（CoreEngine）：**
- ✅ WebSocket 框架已搭建（`/stream` 端点）
- ❌ 消息处理逻辑未实现
- ❌ 流式处理逻辑未实现

**客户端：**
- ❌ WebSocket 客户端未实现
- ❌ 流式处理逻辑未实现

---

## 三、两种方式的对比

### 3.1 HTTP 整句翻译 vs WebSocket 流式翻译

| 特性 | HTTP 整句翻译 | WebSocket 流式翻译 |
|------|--------------|-------------------|
| **实现状态** | ✅ 已完成 | ⚠️ 框架已搭建 |
| **使用场景** | 离线音频文件翻译 | 实时对话翻译 |
| **延迟** | 1-2 秒（整句） | 0.5-1 秒（实时） |
| **复杂度** | 简单 | 复杂 |
| **资源消耗** | 较低 | 较高 |
| **用户体验** | 一般 | 优秀 |

### 3.2 使用建议

**使用 HTTP 整句翻译：**
- 翻译预录制的音频文件
- 不需要实时反馈
- 简单的应用场景

**使用 WebSocket 流式翻译：**
- 实时对话翻译
- 需要低延迟
- 需要实时反馈
- 长时间对话场景

---

## 四、实现优先级

### 4.1 客户端 UI

**优先级：高**

**原因：**
- 用户直接接触的界面
- 没有 UI 无法使用系统
- 是完整功能的关键部分

**实现步骤：**
1. 先实现简单的命令行客户端（快速验证）
2. 再实现图形界面（Chrome Extension 或 Electron）

### 4.2 WebSocket 流式翻译

**优先级：中**

**原因：**
- HTTP 整句翻译已经可用
- 流式翻译是优化功能
- 可以先用 HTTP 接口验证功能

**实现步骤：**
1. 先完善 HTTP 接口（已完成）
2. 再实现 WebSocket 流式接口
3. 最后优化延迟和体验

---

## 五、总结

### 5.1 客户端 UI

**定义：** 用户直接使用的界面程序，负责音频采集、服务调用、结果展示

**类型：** Chrome Extension、Electron、移动端、Web PWA

**功能：** 音频 I/O、服务通信、用户界面、配置管理

**状态：** 框架已搭建，UI 未完成

### 5.2 WebSocket 流式翻译

**定义：** 基于 WebSocket 的实时、双向通信翻译方式

**特点：** 低延迟、实时反馈、增量处理

**协议：** 启动 → 发送音频 → 接收结果 → 停止

**状态：** 框架已搭建，处理逻辑未实现

### 5.3 关系

```
客户端 UI
    │
    ├─── HTTP 整句翻译 ────> CoreEngine ────> 返回完整结果
    │
    └─── WebSocket 流式翻译 ─> CoreEngine ────> 实时推送结果
```

两者都是客户端 UI 与 CoreEngine 通信的方式，WebSocket 流式翻译提供更好的实时体验。

---

**文档结束**

